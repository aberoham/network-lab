set -e

########################################################################
# Logging
#

ESC="$(printf '\033')"
NORMAL="${ESC}[0m"
RED="${ESC}[31;1m"
GREEN="${ESC}[32;1m"
YELLOW="${ESC}[33;1m"
BLUE="${ESC}[34;1m"
BEGINNING="$(printf '\015\033')[K"

log_begin_msg () {
    printf "${BEGINNING}"
    printf "${BLUE}[…]${NORMAL} $1${BLUE}...${NORMAL} "
}
log_ok_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$GREEN[✔]$NORMAL $1."
}
log_warn_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$YELLOW[⚡]$NORMAL $1!"
}
log_error_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$RED[✘]$NORMAL $1!"
    exit 1
}
log_info_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$BLUE[∗]$NORMAL $1."
}

########################################################################
# Environment
#

oobmac=02:00:00:00:00:01

check_dependencies() {
    log_begin_msg "Checking if dependencies are present"
    for exec in \
        busybox \
        strings \
        qemu-system-x86_64 \
        tmux vde_switch \
        start-stop-daemon \
        ssh-keygen \
        $DEPENDENCIES; do
        command -v $exec > /dev/null || log_error_msg "$exec is not installed"
    done
    log_ok_msg "All dependencies are met"
}

setup_tmp () {
    TMP=$(mktemp -d)
    trap "ret=$? ; cleanup" EXIT
    log_info_msg "TMP is $TMP"
}

# Run our lab in tmux
setup_screen() {
    if [ -z "$TMUX" ] || [ x"$(tmux -L "$LABNAME" list-panes -F '#{session_name}')" != x"$LABNAME" ]; then
        unset TMUX
        exec tmux  -L "$LABNAME" new-session -s "$LABNAME" -n main \
            "$PROGNAME $PROGARGS || read"
    elif [ -z "$TMUX" ] || [ x"$(tmux display-message -p '#{session_name}')" != x"$LABNAME" ]; then
        log_error_msg "lab already running"
    fi
    sleep 1
    tmux set-option prefix C-b
    tmux set-hook window-linked "set-option -w remain-on-exit on"
    tmux bind-key r respawn-window
    printf "\e]2;main\a"
}

tmux_resize() {
    local name=$1
    local width=$2
    local height=$3
    shift 3
    if tmux set -w -t $name force-width $width 2> /dev/null; then
        tmux set -w -t $name force-height $height
    else
        tmux resize-window -t $name -x $width -y $height
    fi
}

display_help() {
    cat <<EOF

Some tmux commands (assuming default keybindings) :
 C-b d     - Detach the lab (resume with "tmux attach -t $LABNAME")
 C-b w     - Select a window
 C-b n     - Next window
 C-b p     - Previous window
 C-b l     - Last window
 C-b ?     - Get help
EOF
    echo "Press enter to exit the lab"
    read a
    done=1
}

# Setup a VDE switch
SWITCH_HUB=1
setup_switch() {
    nb=$1 ; shift
    [ ! -f "$TMP/switch-$nb.conf" ] || return 0
    log_begin_msg "Setup switch $nb"
    cat <<EOF > "$TMP/switch-$nb.conf"
plugin/add /usr/lib/vde2/plugins/pdump.so
pdump/filename $TMP/switch-$nb.pcap
pdump/buffered 0
${SWITCH_MON+pdump/active 1}
EOF
    start-stop-daemon -b --no-close --make-pidfile --pidfile "$TMP/switch-$nb.pid" \
        --start --startas $(command -v vde_switch) -- \
        --sock "$TMP/switch-$nb.sock" --mgmt "$TMP/switch-management-$nb.sock" \
        --rcfile "$TMP/switch-$nb.conf" ${SWITCH_HUB+--hub}
    # Management socket can be used with:
    #    socat - UNIX-CONNECT:"$TMP/switch-management-$nb.sock"
    log_ok_msg "Switch $nb started"
}

mac_address () {
    mac_counter=$(cat $TMP/mac-counter 2> /dev/null || echo 1)
    printf "50:54:33:00:%02X:%02X" \
           $((mac_counter / 256)) \
           $((mac_counter % 256))
    echo $((mac_counter + 1)) > $TMP/mac-counter
}

tcp_port () {
    tcp_counter=$(cat $TMP/tcp-counter 2> /dev/null || awk 'BEGIN{srand(); print int(9400+rand()*5000)}')
    echo $((tcp_counter + 1)) > $TMP/tcp-counter
    echo $tcp_counter
}

# $1 == hostname
# $2 == local port
# $3 == username
add_ssh_config () {
    [ -f $TMP/id_rsa ] || ssh-keygen -m pem -q -t rsa -b 2048 -N "" -f $TMP/id_rsa
    cat <<EOF >> $TMP/ssh_config
# $1.lab
Host $1.lab
  StrictHostKeyChecking no
  UserKnownHostsFile /dev/null
  PasswordAuthentication no
  KexAlgorithms +diffie-hellman-group1-sha1
  Ciphers +aes128-cbc
  PubkeyAcceptedKeyTypes +ssh-rsa
  IdentitiesOnly yes
  LogLevel FATAL
  IdentityFile $TMP/id_rsa
  User ${3:-root}
  Port $2
  Hostname 127.0.0.1

EOF
    # Password for is .Juniper. for non-root user.
    cat <<EOF > $TMP/ssh-junos.conf
system {
  protect: host-name $1;
  protect: login {
    user ${3:-root} {
      uid 2000;
      class super-user;
      authentication {
        ssh-rsa "$(cat $TMP/id_rsa.pub)";
        encrypted-password "$6$DM.sF/YV$lBF3Fi.OhyuRDNyVZPzaYSnPb.mE285t6lmIvYshbhVorUJhbI1RGA/i0812cn/uNeuzd2aNqC6iWj4k0bkk4."; ## SECRET-DATA
      }
    }
  }
  protect: root-authentication {
    encrypted-password "\$1\$C.KNZIWW\$3tov9xZ5wolEhW1PjdbDV0"; ## SECRET-DATA
  }
  protect: syslog {
    file messages {
      any any;
      authorization info;
    }
  }
  services {
    protect: ssh {
      root-login allow;
    }
    protect: netconf {
      ssh;
    }
  }
}
EOF

    log_info_msg "Connect with ssh -F $TMP/ssh_config $1.lab"
}

cleanup () {
    set +e
    [ x"$done" = x"1" ] || {
        printf "${BEGINNING}"
        echo "$BOLD$RED[✘]$NORMAL Got a fatal error. Press enter to terminate everything!"
        read a
    }
    for pid in $TMP/*.pid; do
        kill -15 -$(cat $pid) 2> /dev/null || true
    done
    sleep 1
    for pid in $TMP/*.pid; do
        kill -9 -$(cat $pid) 2> /dev/null || true
    done
    rm -rf $TMP
    tmux kill-session -t $LABNAME
}

########################################################################
# VM spawning
#

spawn () {
    kind=$1
    shift

    NAME=$1
    shift

    NET=""

    case $STATE,$kind in
        SETUP,ns)
            if [ $uts = ${NAME%%/*} ]; then
                ip netns add ${NAME#*/}
            fi
            return 0
            ;;
        SETUP,*)
            return 0
            ;;
    esac

    while [ $# -gt 1 ]; do
        case $1 in
            network|networks)
                NET="$NET $2"
                NET="$(echo $NET | tr , ' ')"
                shift 2
                ;;
            *)
                log_error_msg "Unknown keyword for spawn \`$1'"
                ;;
        esac
    done

    for net in $NET; do
        case $net in
            oob) ;;
            rocker*) setup_switch ${net#rocker} ;;
            *) setup_switch $net ;;
        esac
    done
    sleep 0.5

    case $kind in
        vm)
            check_kernel
            setup_initrd
            start_vm
            ;;
        img)
            start_img
            ;;
        ns)
            start_ns
            ;;
        juniper-vrr)
            start_juniper_vrr
            ;;
        juniper-vsrx)
            start_juniper_vsrx
            ;;
        juniper-vqfx)
            start_juniper_vqfx
            ;;
        juniper-vmx)
            start_juniper_vmx
            ;;
        juniper-firefly)
            start_juniper_firefly
            ;;
        cumulus-vx)
            start_cumulus_vx
            ;;
        sonic)
            start_sonic
            ;;
        cisco-iosxrv)
            start_cisco_iosxrv
            ;;
        cisco-nxos)
            start_cisco_nxos
            ;;
        hp-vsr1000)
            start_hp_vsr1000
            ;;
        *)
            log_error_msg "Unknown kind of VM \`$kind'"
            ;;
    esac
}

check_kernel() {
    [ ! -f $TMP/kernel-checked ] || return 0
    log_begin_msg "Checking kernel version"
    [ -f "$KERNEL" ] || log_error_msg "Unable to find kernel $KERNEL"
    [ -r "$KERNEL" ] || log_error_msg "Kernel $KERNEL is not readable.\n    Try \`setfacl -m u:$USER:r $KERNEL'"

    # A recent version of `file` is able to extract the
    # information. Since it is not widely available, let use some hack
    # method.
    VERSION=$(cat <<EOF |
cat
gunzip  \\\037\\\213\\\010 xy
unxz    \\\3757zXZ\\\000   abcde
bunzip2 BZh                xy
unlzma  \\\135\\\0\\\0\\\0 xxx
EOF
              while read cmd sig1 sig2; do
                  case $sig1,$sig2 in
                      ,) poss="0:_" ;;
                      *) poss=$(tr "${sig1}\n${sig2}" "\n${sig2}=" < "$KERNEL" | grep -abo "^${sig2}" || true) ;;
                  esac
                  [ -n "$poss" ] || continue
                  for pos in $poss; do
                      pos=${pos%%:*}
                      tail -c+$pos "$KERNEL" | $cmd 2> /dev/null | strings -20 | \
                          grep ^Linux.version | head -1
                  done
              done | head -1)

    [ -n "$VERSION" ] || log_error_msg "Unable to determine version for $KERNEL"
    VERSION="${VERSION#Linux version }"
    VERSION="${VERSION%% *}"
    log_ok_msg "Found kernel $VERSION"

    log_begin_msg "Check kernel configuration"
    CONFIG="$(dirname $KERNEL)/config-$VERSION"
    [ -f "$CONFIG" ] || log_error_msg "Unable to find configuration file $CONFIG"
    cat <<EOF | while read el; do
9P_FS=[ym]
NET_9P=[ym]
NET_9P_VIRTIO=[ym]
VIRTIO=[ym]
VIRTIO_PCI=[ym]
VIRTIO_NET=[ym]
SERIAL_8250=y
SERIAL_8250_CONSOLE=y
TMPFS=y
BLK_DEV_INITRD=y
DEVTMPFS=[ym]
EOF
        grep -qx "CONFIG_$el" $CONFIG || log_error_msg "Kernel not configured with CONFIG_$el"
    done

    if grep -Eqc "CONFIG_OVERLAYFS_FS=[ym]" $CONFIG; then
        log_ok_msg "Kernel configuration checked. overlayfs present"
        UNION="${UNION}${UNION+ }overlayfs"
    elif grep -Eqc "CONFIG_OVERLAY_FS=[ym]" $CONFIG; then
        log_ok_msg "Kernel configuration checked. overlayfs present"
        UNION="${UNION}${UNION+ }overlay"
    fi
    if grep -qc "CONFIG_AUFS_FS=[ym]" $CONFIG; then
        log_ok_msg "Kernel configuration checked. AUFS present"
        UNION="${UNION}${UNION+ }aufs"
    fi
    [ -n "$UNION" ] || \
        log_error_msg "Kernel configuration checked. Neither overlayfs nor AUFS present"

    log_begin_msg "Search for modules"
    for dir in "$(dirname $KERNEL)/lib/modules/$VERSION" \
                   "$(dirname $KERNEL)/../lib/modules/$VERSION" \
                   "/lib/modules/$VERSION"; do
        [ -d $dir ] || continue
        MODULES="$dir"
        break
    done
    if [ -z "$MODULES" ]; then
        log_warn_msg "Unable to find module directory"
    else
        log_ok_msg "Modules are in $MODULES"
    fi
    : > $TMP/kernel-checked
}

setup_initrd () {
    [ ! -f $TMP/initrd.gz ] || return 0
    log_begin_msg "Build initrd"
    DESTDIR=$TMP/initrd
    mkdir -p $DESTDIR

    # Copy busybox and eventually insmod
    bins="busybox"
    busybox --list | grep -qFx insmod || bins="$bins insmod"
    for bin in $bins; do
        install -D "$(command -v $bin)" ${DESTDIR}/bin/$bin
        for x in $(ldd "$(command -v $bin)" 2> /dev/null | sed -e '
               /\//!d;
               /linux-gate/d;
               /=>/ {s/.*=>[[:blank:]]*\([^[:blank:]]*\).*/\1/};
               s/[[:blank:]]*\([^[:blank:]]*\) (.*)/\1/' 2>/dev/null); do
            [ -f "${DESTDIR}/$x" ] || install -D "$x" "${DESTDIR}/$x"
        done
    done

    # Configure busybox
    ${DESTDIR}/bin/busybox --install ${DESTDIR}/bin

    # Add modules
    [ -z "$MODULES" ] || {
        modules="9pnet_virtio 9p virtio_pci virtio_net $UNION"
        for mod in $modules; do
            base=${MODULES}/../../..
            cmd="modprobe --all --set-version=${VERSION} -d ${base} --ignore-install --quiet --show-depends $mod"
            $cmd > /dev/null || {
                depmod -b ${base} ${VERSION} 2> /dev/null && $cmd > /dev/null || {
                        log_warn_msg "Unable to find module $mod"
                        log_begin_msg "Continue building initrd"
                }
            }
            $cmd | while read prefix kmod options ; do
                [ "${prefix}" = "insmod" ] || continue
                grep -qFw "$kmod" ${DESTDIR}/modules 2> /dev/null || {
                    install -D "$kmod" "${DESTDIR}/${kmod}"
                    echo $prefix $kmod $options >> ${DESTDIR}/modules
                }
            done
        done
    }

    # Copy this program
    >  ${DESTDIR}/init echo '#!/bin/sh'
    >> ${DESTDIR}/init cat ../common/lab-setup
    chmod +x ${DESTDIR}/init

    # Create /tmp
    mkdir ${DESTDIR}/tmp

    # Build initrd
    (cd "${DESTDIR}" && find . | cpio --quiet -R 0:0 -o -H newc | gzip > $TMP/initrd.gz)

    log_ok_msg "initrd built in $TMP/initrd.gz"
}

link () {
    case ${#@} in
        0|1)
            log_error_msg "Missing arguments for link"
            ;;
        2)
            ip link add type veth peer netns $2
            last=$(ip -o l l | tail -1 | awk  -F'(: |@)' '{print $2}')
            case $1 in
                main)
                    ip link set up dev $last
                    ;;
                *)
                    ip link set netns $1 dev $last
                    ;;
            esac
            ;;
        *)
            ip link add type bridge
            bridge=$(ip -o l l | tail -1 | awk  -F'(: |@)' '{print $2}')
            ip link set up dev $bridge
            for l in "$@"; do
                case $l in
                    main)
                        ip link add type veth
                        last=$(ip -o l l | tail -1 | awk  -F'(: |@)' '{print $2}')
                        ip link set master $bridge dev $last
                        ip link set up dev $last
                        last=$(ip -o l l | tail -2 | head -1 | awk  -F'(: |@)' '{print $2}')
                        ip link set up dev $last
                        ;;
                    *)
                        ip link add type veth peer netns $l
                        last=$(ip -o l l | tail -1 | awk  -F'(: |@)' '{print $2}')
                        ip link set master $bridge dev $last
                        ip link set up dev $last
                        ;;
                esac
            done
            ;;
    esac
}


start_ns () {
    local vm ns
    vm=${NAME%%/*}
    ns=${NAME#*/}
    log_info_msg "Start namespace $ns in VM $vm"

    cat <<EOF  > "$TMP/ns-$vm--$ns.exec"
printf "\e]2;$NAME\a"
while true; do
    sleep 1
    ssh -n -F $TMP/ssh_config $vm.lab test -f /tmp/ready || continue
    break
done
ssh -t -F $TMP/ssh_config $vm.lab unshare --pid --mount --uts --fork --mount-proc \
        env uts=$ns STATE=BEGIN NOGETTY=1 nsenter --net=/run/netns/$ns /mnt/lab/setup
EOF
    chmod +x "$TMP/ns-$vm--$ns.exec"
    tmux set-option -wt $(tmux new-window -Pdn $NAME "$TMP/ns-$vm--$ns.exec") remain-on-exit on
}

start_vm () {
    name=$NAME
    log_info_msg "Start VM $name"
    netargs=""
    rockerports=""
    count=0
    for net in $NET; do
        case $net in
            oob)
                ssh=$(tcp_port)
                netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22${hostfwd+,hostfwd=}${hostfwd}"
                netargs="$netargs -device virtio-net-pci,mac=$oobmac,netdev=oob"
                [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
                add_ssh_config $NAME $ssh
                ;;
            rocker*)
                net=${net#rocker}
                netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
                rockerports="${rockerports} net${count}"
                ;;
            *)
                mac=$(mac_address)
                netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
                netargs="$netargs -device virtio-net-pci,mac=$mac,netdev=net${count}"
                ;;
        esac
        count=$((count+1))
    done
    [ -z "$rockerports" ] || {
        count=0
        str=""
        for p in $rockerports; do
            str="${str},ports[${count}]=$p"
            count=$((count+1))
        done
        netargs="$netargs -device rocker,name=sw1,len-ports=${count}${str}"
    }

    [ "$DISK" = "" ] || \
        netargs="$netargs -drive file=$DISK,if=virtio,media=disk"

    # /root is mounted with version 9p2000.u to allow access to /dev,
    # /sys and to mount new partitions over them. This is not the case
    # for 9p2000.L.
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-192M} \
     -cpu host \
     -smp ${CPUS:-1} \
     -device virtio-rng \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     -chardev socket,id=charserial1,path=$TMP/vm-$name-serial.pipe,server=on,wait=off \
     -device isa-serial,chardev=charserial1,id=serial1 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     -fsdev local,security_model=passthrough,id=fsdev-root,path=${ROOT},multidevs=remap \
     -device virtio-9p-pci,id=fs-root,fsdev=fsdev-root,mount_tag=rootshare \
     -fsdev local,security_model=none,id=fsdev-home,path=${HOME},multidevs=remap \
     -device virtio-9p-pci,id=fs-home,fsdev=fsdev-home,mount_tag=homeshare \
     -fsdev local,security_model=none,id=fsdev-lab,path=${PWD} \
     -device virtio-9p-pci,id=fs-lab,fsdev=fsdev-lab,mount_tag=labshare \
     -fsdev local,security_model=none,id=fsdev-common,path=${PWD}/../common,readonly=on \
     -device virtio-9p-pci,id=fs-common,fsdev=fsdev-common,mount_tag=commonshare \
     -fsdev local,security_model=none,id=fsdev-tmp,path=${TMP} \
     -device virtio-9p-pci,id=fs-tmp,fsdev=fsdev-tmp,mount_tag=tmpshare \
     -fsdev local,security_model=none,id=fsdev-modules,path=${MODULES}/..,readonly=on \
     -device virtio-9p-pci,id=fs-modules,fsdev=fsdev-modules,mount_tag=moduleshare \
     \
     -gdb unix:$TMP/vm-$name-gdb.pipe,server=on,wait=off \
     -kernel $KERNEL \
     -no-reboot \
     -initrd $TMP/initrd.gz \
     -append "uts=$name console=ttyS0 panic=1 TERM=$TERM quiet net.ifnames=0 nokaslr $KERNELPARAMS" \
     $netargs \
     $QEMU_ARGS
EOF
    log_info_msg "monitor listening on  $TMP/vm-$name-console.pipe"
    log_info_msg "ttyS1 listening on    $TMP/vm-$name-serial.pipe"
    log_info_msg "GDB server            gdb -ex='target remote $TMP/vm-$name-gdb.pipe'"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $NAME "$TMP/vm-$name.exec") remain-on-exit on
}

start_img () {
    # This starts a VM from a provided image ($NAME.img). The
    # provisioning is not done but we prepare an additional vfat disk
    # with the content of the $NAME/ directory.
    name=$NAME
    log_info_msg "Start image $name"
    netargs=""
    count=0
    for net in $NET; do
        case $net in
            oob)
                ssh=$(tcp_port)
                netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22"
                netargs="$netargs -device virtio-net-pci,mac=$oobmac,netdev=oob"
                [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
                add_ssh_config $NAME $ssh ${SSH_USER:-root}
                ;;
            *)
                mac=$(mac_address)
                netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
                netargs="$netargs -device virtio-net-pci,mac=$mac,netdev=net${count}"
                ;;
        esac
        count=$((count+1))
    done

    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"
qemu-img create -f qcow2 -F qcow2 -b $PWD/$name.img $TMP/vm-$name.img ${QEMU_IMG_SIZE}
mkdir -p $TMP/metadata-$name
cp -a $name/* $TMP/metadata-$name/. 2> /dev/null
cp $TMP/id_rsa.pub $TMP/metadata-$name
cat <<END > $TMP/metadata-$name/meta-data
local-hostname: $name
END
cat user-data.$name - <<END 2> /dev/null > $TMP/metadata-$name/user-data
#cloud-config
users:
  - name: root
    plain_text_passwd: .Linux.
    ssh-authorized-keys:
      - $(cat $TMP/id_rsa.pub)
END
cp network-config.$name $TMP/metadata-$name/network-config 2> /dev/null
cp $name/* $TMP/metadata-$name/. 2> /dev/null
genisoimage -output $TMP/metadata-$name.iso -volid cidata -joliet -rock $TMP/metadata-$name/*
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-256M} \
     -cpu host \
     -smp ${CPUS:-1} \
     -device virtio-rng \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     -chardev socket,id=charserial1,path=$TMP/vm-$name-serial.pipe,server=on,wait=off \
     -device isa-serial,chardev=charserial1,id=serial1 \
     \
     -boot c \
     -drive file=$TMP/vm-$name.img,if=virtio,media=disk \
     -drive file=$TMP/metadata-$name.iso,format=raw,if=ide,media=cdrom,read-only=on \
     \
     -gdb unix:$TMP/vm-$name-gdb.pipe,server=on,wait=off \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs \
     $QEMU_ARGS
EOF
    log_info_msg "monitor listening on  $TMP/vm-$name-console.pipe"
    log_info_msg "ttyS1 listening on    $TMP/vm-$name-serial.pipe"
    log_info_msg "GDB server            gdb -ex='target remote $TMP/vm-$name-gdb.pipe'"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
}

start_juniper_vrr () {
    name=$NAME
    log_info_msg "Start Juniper VRR $name"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22"
    netargs="$netargs -device e1000,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh juniper
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device e1000,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    # Have a look at /etc/rc.vmguest for what is done
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-vrr.img $TMP/junos-$name.img
truncate -s 10M $TMP/metadata-$name.img
mkfs.vfat $TMP/metadata-$name.img
mkdir -p $TMP/metadata-$name/boot
cat - $TMP/ssh-junos.conf junos-common.conf junos-$name.conf <<END 2>/dev/null > $TMP/metadata-$name/juniper.conf
interfaces {
  protect: em0 unit 0 {
    family inet dhcp;
  }
}
END
cat <<END > $TMP/metadata-$name/boot/loader.conf
console="comconsole"
vm_retype="RE-VRR"
END
tar -C $TMP/metadata-$name -zcf $TMP/metadata-$name.tgz .
mcopy -i $TMP/metadata-$name.img $TMP/metadata-$name.tgz ::/vrr-config.tgz
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-1G} \
     -smbios type=0,vendor=Juniper -smbios type=1,manufacturer=Juniper,product=VRR \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/junos-$name.img,if=ide,media=disk \
     -drive file=$TMP/metadata-$name.img,format=raw,if=none,media=disk,id=metadata \
     -usb -device usb-storage,drive=metadata \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
    tmux_resize $name 80 24
}

start_juniper_vqfx () {
    name=$NAME
    setup_switch $name-internal
    log_info_msg "Start Juniper vQFX $name (RE)"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22"
    netargs="$netargs -device e1000,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh juniper
    netargs="$netargs -netdev vde,sock=$TMP/switch-$name-internal.sock,id=pfe"
    netargs="$netargs -device e1000,mac=$(mac_address),netdev=pfe"  # PFE
    netargs="$netargs -device e1000,mac=$(mac_address)" # unused
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device e1000,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done
    cat <<EOF > "$TMP/vm-$name-re.exec"
#!/bin/sh
printf "\e]2;$name\a"
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-vqfx-re.img $TMP/junos-$name-re.img
truncate -s 10M $TMP/metadata-$name.img
mkfs.vfat $TMP/metadata-$name.img
mkdir -p $TMP/metadata-$name/boot
cat - $TMP/ssh-junos.conf junos-common.conf junos-$name.conf <<END 2>/dev/null > $TMP/metadata-$name/juniper.conf
interfaces {
  protect: em0 {
    unit 0 {
      family inet dhcp;
    }
  }
  protect: em1 {
    unit 0 {
      family inet {
        address 169.254.0.2/24;
      }
    }
  }
}
END
cat <<END > $TMP/metadata-$name/boot/loader.conf
console="vidconsole,comconsole"
END
tar -C $TMP/metadata-$name -zcf $TMP/metadata-$name.tgz .
mcopy -i $TMP/metadata-$name.img $TMP/metadata-$name.tgz ::/vmm-config.tgz
exec start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name-re.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-1G} \
     -cpu host \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/junos-$name-re.img,if=ide,media=disk \
     -drive file=$TMP/metadata-$name.img,format=raw,if=none,media=disk,id=metadata \
     -usb -device usb-storage,drive=metadata \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-re-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on $TMP/vm-$name-re-console.pipe"
    chmod +x "$TMP/vm-$name-re.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name/RE "$TMP/vm-$name-re.exec") remain-on-exit on
    tmux_resize $name/RE 80 24

    log_info_msg "Start Juniper vQFX $name (PFE)"
    netargs=""
    netargs="$netargs -device e1000,mac=$(mac_address)" # OOB (not used)
    netargs="$netargs -netdev vde,sock=$TMP/switch-$name-internal.sock,id=re"
    netargs="$netargs -device e1000,mac=$(mac_address),netdev=re"  # RE
    cat <<EOF > "$TMP/vm-$name-pfe.exec"
#!/bin/sh
printf "\e]2;$name\a"
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-vqfx-pfe.img $TMP/junos-$name-pfe.img
truncate -s 10M $TMP/metadata-$name-pfe.img
mkfs.vfat $TMP/metadata-$name-pfe.img
mkdir -p $TMP/metadata-$name-pfe/boot
cat <<END > $TMP/metadata-$name-pfe/boot/loader.conf
console="vidconsole,comconsole"
END
tar -C $TMP/metadata-$name-pfe -zcf $TMP/metadata-$name-pfe.tgz .
mcopy -i $TMP/metadata-$name-pfe.img $TMP/metadata-$name-pfe.tgz ::/vqfx-config.tgz
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name-pfe.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -cpu host,level=9,-avx2,-vmx \
     -m ${MEM:-1G} \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/junos-$name-pfe.img,if=ide,media=disk \
     -drive file=$TMP/metadata-$name-pfe.img,format=raw,if=none,media=disk,id=metadata \
     -usb -device usb-storage,drive=metadata \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-pfe-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-pfe-console.pipe"
    chmod +x "$TMP/vm-$name-pfe.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name/PFE "$TMP/vm-$name-pfe.exec") remain-on-exit on
    tmux_resize $name/PFE 80 24
}

start_juniper_vmx () {
    name=$NAME
    setup_switch $name-internal
    log_info_msg "Start Juniper vMX $name (RE)"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22${hostfwd+,hostfwd=}${hostfwd}"
    netargs="$netargs -device e1000,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh juniper
    netargs="$netargs -netdev vde,sock=$TMP/switch-$name-internal.sock,id=pfe"
    netargs="$netargs -device virtio-net-pci,mac=$(mac_address),netdev=pfe"  # PFE
    nbports=0
    for net in $NET; do
        nbports=$((nbports + 1))
    done
    cat <<EOF > "$TMP/vm-$name-re.exec"
#!/bin/sh
printf "\e]2;$name RE\a"
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-vmx-re.img $TMP/junos-$name-re.img
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-vmx-re-hdd.img $TMP/junos-$name-re-hdd.img
truncate -s 10M $TMP/metadata-$name.img
mkfs.vfat $TMP/metadata-$name.img
mkdir -p $TMP/metadata-$name/boot
cat - $TMP/ssh-junos.conf junos-$name.conf junos-common.conf <<END 2>/dev/null > $TMP/metadata-$name/juniper.conf
interfaces {
  protect: fxp0 unit 0 {
    family inet dhcp;
  }
}
chassis {
  fpc 0 {
    protect: lite-mode;
    pic 0 {
      protect: number-of-ports ${nbports};
    }
    # protect: interface-type xe;
  }
}
END
# This comes from metadata-usb-re.img
cat <<END > $TMP/metadata-$name/boot/loader.conf
vmtype="0"
vm_retype="RE-VMX"
vm_i2cid="0xBAA"
vm_chassis_i2cid="161"
vm_instance="0"
console="vidconsole,comconsole"
END
tar -C $TMP/metadata-$name -zcf $TMP/metadata-$name.tgz .
mcopy -i $TMP/metadata-$name.img $TMP/metadata-$name.tgz ::/vmm-config.tgz
exec start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name-re.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-1G} \
     -cpu host \
     -smbios type=0,vendor=Juniper -smbios type=1,manufacturer=VMX,product=VM-vcp_vmx1-161-re-0,version=0.1.0 \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/junos-$name-re.img,if=ide,media=disk \
     -drive file=$TMP/junos-$name-re-hdd.img,if=ide,media=disk \
     -drive file=$TMP/metadata-$name.img,format=raw,if=none,media=disk,id=metadata \
     -usb -device usb-storage,drive=metadata \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-re-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-re-console.pipe"
    chmod +x "$TMP/vm-$name-re.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name/RE "$TMP/vm-$name-re.exec") remain-on-exit on
    tmux_resize $name/RE 80 24

    log_info_msg "Start Juniper vMX $name (PFE)"
    vcpus=4
    netargs=""
    netargs="$netargs -netdev user,id=oob"
    netargs="$netargs -device virtio-net-pci,mac=$(mac_address),netdev=oob" # OOB
    netargs="$netargs -netdev vde,sock=$TMP/switch-$name-internal.sock,id=re"
    netargs="$netargs -device virtio-net-pci,mac=$(mac_address),netdev=re"  # RE
    count=0
    for net in $NET; do
        mac=$(mac_address)
        bridge=$(( $count / 16 + 1 ))
        if [ $(( $count % 16  )) -eq 0 ]; then
            netargs="$netargs -device pcie-root-port,bus=pcie.0,id=rp${bridge},slot=${bridge}"
            netargs="$netargs -device pcie-pci-bridge,id=br${bridge},bus=rp${bridge}"
        fi
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device virtio-net-pci,mac=$mac,netdev=net${count},bus=br${bridge},addr=$(( $count % 16 + 1 ))"
        count=$((count+1))
    done
    cat <<EOF > "$TMP/vm-$name-pfe.exec"
#!/bin/sh
printf "\e]2;$name PFE\a"
if qemu-img info $PWD/../images/junos-vmx-pfe.img | grep -qFx 'file format: qcow2'; then
  qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-vmx-pfe.img $TMP/junos-$name-pfe.img
else
  qemu-img create -q -f qcow2 -F raw -b $PWD/../images/junos-vmx-pfe.img $TMP/junos-$name-pfe.img
fi
truncate -s 10M $TMP/metadata-$name-pfe.img
mkfs.vfat $TMP/metadata-$name-pfe.img
mkdir -p $TMP/metadata-$name-pfe/boot
cat <<END > $TMP/metadata-$name-pfe/boot/loader.conf
vmtype="1"
vm_retype="RE-VMX"
vm_i2cid="0xBAA"
vm_chassis_i2cid="161"
vm_instance="0"
console="vidconsole,comconsole"
END
tar -C $TMP/metadata-$name-pfe -zcf $TMP/metadata-$name-pfe.tgz .
mcopy -i $TMP/metadata-$name-pfe.img $TMP/metadata-$name-pfe.tgz ::/vmx-config.tgz
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name-pfe.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -smp cpus=$vcpus \
     -machine q35 \
     -cpu host \
     -m ${MEM:-3G} \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/junos-$name-pfe.img,if=virtio,media=disk \
     -drive file=$TMP/metadata-$name-pfe.img,format=raw,if=none,media=disk,id=metadata \
     -usb -device usb-storage,drive=metadata \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-pfe-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-pfe-console.pipe"
    chmod +x "$TMP/vm-$name-pfe.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name/PFE "$TMP/vm-$name-pfe.exec") remain-on-exit on
    tmux_resize $name/PFE 80 24
}

start_juniper_vsrx () {
    name=$NAME
    log_info_msg "Start Juniper vSRX $name"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22"
    netargs="$netargs -device virtio-net-pci,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh juniper
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device virtio-net-pci,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-vsrx.img $TMP/junos-$name.img
truncate -s 10M $TMP/metadata-$name.img
mkfs.vfat $TMP/metadata-$name.img
mkdir -p $TMP/metadata-$name/boot
cat - $TMP/ssh-junos.conf junos-common.conf junos-$name.conf <<END 2>/dev/null > $TMP/metadata-$name/juniper.conf
interfaces {
  protect: fxp0 {
    unit 0 {
      family inet dhcp;
    }
  }
}
END
cat <<END > $TMP/metadata-$name/boot/loader.conf
vm_local_rpio="1"
END
tar -C $TMP/metadata-$name -zcf $TMP/metadata-$name.tgz .
mcopy -i $TMP/metadata-$name.img $TMP/metadata-$name.tgz ::/vsrx-config.tgz
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-4G} \
     -cpu host \
     -smp cpus=2 \
     -smbios type=0,vendor=Juniper -smbios type=1,manufacturer=Juniper,product=VSRX \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/junos-$name.img,if=ide,media=disk \
     -drive file=$TMP/metadata-$name.img,format=raw,if=none,media=disk,id=metadata \
     -usb -device usb-storage,drive=metadata \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
    tmux_resize $name 80 24
}

start_juniper_firefly () {
    # This is not the same as VSRX as the provisioning is different
    name=$NAME
    netargs=""
    netargs="$netargs -netdev user,id=tftp,tftp=$TMP/tftp,hostname=$name"
    netargs="$netargs -device e1000,mac=$(mac_address),netdev=tftp"
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device e1000,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    log_info_msg "Start Juniper vSRX $name"
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/junos-firefly.img $TMP/junos-$name.img
mkdir -p $TMP/tftp
cat junos-common.conf junos-$name.conf 2>/dev/null > $TMP/tftp/$name.conf
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -cpu host \
     -smp cpus=2 \
     -rtc base="2014-06-09" \
     -smbios 'type=0,vendor=,version=' \
     -smbios 'type=1,product=,version=' \
     -m ${MEM:-512M} \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/junos-$name.img,if=ide,media=disk \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
    tmux_resize $name 80 24
}

start_cumulus_vx () {
    name=$NAME
    log_info_msg "Start Cumulus VX $name"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22"
    netargs="$netargs -device virtio-net-pci,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh cumulus
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device virtio-net-pci,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/cumulus-vx.img $TMP/cumulus-$name.img
truncate -s 10M $TMP/metadata-$name.img
mkfs.vfat $TMP/metadata-$name.img

cat <<END > $TMP/ztp-$name
#!/bin/sh
# CUMULUS-AUTOPROVISIONING

echo 127.0.1.1 $name > /etc/hosts
echo $name > /etc/hostname
hostname -F /etc/hostname

install -d -o cumulus -g cumulus -m 0700 /home/cumulus/.ssh
echo $(cat $TMP/id_rsa.pub) >> /home/cumulus/.ssh/authorized_keys
chown cumulus:cumulus /home/cumulus/.ssh/authorized_keys
chmod 600 /home/cumulus/.ssh/authorized_keys

sed -i 's/^\(%sudo.*\)ALL$/\1NOPASSWD: ALL/' /etc/sudoers

END

[ ! -d $PWD/$name ] || {
  echo "base64 -d <<'END' | tar --no-same-owner -C / -zxf -" >> $TMP/ztp-$name
  tar -C $PWD/$name --exclude=./run -hzcf - . | base64 >> $TMP/ztp-$name
  echo END >> $TMP/ztp-$name
}

[ ! -f $PWD/$name/run ] || cat $PWD/$name/run >> $TMP/ztp-$name

mcopy -i $TMP/metadata-$name.img $TMP/ztp-$name ::/cumulus-ztp

exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-1G} \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/cumulus-$name.img,if=ide,media=disk \
     -drive file=$TMP/metadata-$name.img,format=raw,if=none,media=disk,id=metadata \
     -usb -device usb-storage,drive=metadata \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
    tmux_resize $name 80 24
}

start_sonic () {
    name=$NAME
    log_info_msg "Start SONiC $name"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22"
    netargs="$netargs -device virtio-net-pci,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh admin
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device virtio-net-pci,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/sonic.img $TMP/sonic-$name.img
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-2G} \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/sonic-$name.img,if=ide,media=disk \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
    tmux_resize $name 80 24
}

start_cisco_iosxrv () {
    # This is for IOS XRv 7+. Compared to 6:
    #  - 2 additional dummy interfaces
    #  - MGMT interface has a different name
    name=$NAME
    log_info_msg "Start Cisco IOS XRv $name"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,tftp=$TMP/metadata-$name,hostfwd=tcp:127.0.0.1:${ssh}-:22${hostfwd+,hostfwd=}${hostfwd}"
    netargs="$netargs -device virtio-net-pci,mac=$oobmac,netdev=oob"
    netargs="$netargs -device virtio-net-pci,mac=$(mac_address)" # control (unused)
    netargs="$netargs -device virtio-net-pci,mac=$(mac_address)" # dev (unused)
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh cisco
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device virtio-net-pci,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"

qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/cisco-iosxrv.img $TMP/cisco-$name.img
mkdir -p $TMP/metadata-$name
cat - cisco-common.conf cisco-$name.conf <<'END' 2>/dev/null > $TMP/metadata-$name/iosxr_config.txt
hostname $name
clock timezone UTC UTC
vrf MGMT
 address-family ipv4 unicast
!
interface MgmtEth0/RP0/CPU0/0
 vrf MGMT
 ipv4 address dhcp
 no shut
!
username cisco
 group root-lr
 group cisco-support
 secret 10 \$6\$GHb941otWliMA41.\$L1OTJWUtD3tOPEM2u2x8fMcCP1my2/JyUMyM7.B6WbM1OxRKLNky9X4tKkn7zEf1nUCObfS3o48uwVwj47PZ9.
!
router static
 vrf MGMT
  address-family ipv4 unicast
   0.0.0.0/0 10.0.2.2
  !
 !
!
xml agent tty
 iteration off
!
ssh server vrf MGMT
ssh server v2
ssh server netconf vrf MGMT
ssh server logging
line default
 session-timeout 4320
 exec-timeout 4320
!
END
echo end >> $TMP/metadata-$name/iosxr_config.txt
cp $TMP/id_rsa.pub $TMP/metadata-$name/public-keys.txt
genisoimage -iso-level 2 -l -V config-1 -relaxed-filenames -quiet -o $TMP/cisco-$name.iso $TMP/metadata-$name

exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-9G} \
     -cpu host \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/cisco-$name.img,if=ide,media=disk \
     -drive file=$TMP/cisco-$name.iso,if=ide,media=cdrom \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     -chardev socket,id=charserial1,path=$TMP/vm-$name-serial1.pipe,server=on,wait=off \
     -device isa-serial,chardev=charserial1,id=serial1 \
     -chardev socket,id=charserial2,path=$TMP/vm-$name-serial2.pipe,server=on,wait=off \
     -device isa-serial,chardev=charserial2,id=serial2 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    # Recent versions of IOS XRv seems to have some bits to retrieve
    # the public key, but I am unable to find exactly where to put it.
    # See /pkg/bin/xrv9k_rp_cloudinit.sh for some related code, and
    # /etc/rc.d/init.d/pd-lxchook-functions.sh.
    cat <<EOF > "$TMP/vm-$name-real.exec"
#!$(command -v expect) -f
spawn $TMP/vm-$name.exec
set timeout 640
expect {
  "Cisco Calvados console" { exp_continue }
  "con0/RP0/CPU0 is now available" { exp_continue }
  "INFRA-INSTAGENT-4-" { exp_continue }
  "MGBL-CVAC-4-CONFIG_START" { exp_continue }
  -re "MGBL-CVAC-.-CONFIG_(DONE|ERROR)" {
    send "\r"
    set timeout 10
    expect "Username: "
    send "cisco\r"
    expect "Password: "
    send "cisco\r"
    expect "RP/0/RP0/CPU0:*#"
    send "crypto key import authentication rsa\r"
    expect "Enter the public key"
    send "$(cat $TMP/id_rsa.pub)\r\r"
    expect "RP/0/RP0/CPU0:*#"
    interact
  }
  timeout {
    send_user "TIMEOUT!\n"
    interact
  }
}
EOF
    log_info_msg "monitor listening on          $TMP/vm-$name-console.pipe"
    log_info_msg "aux console listening on      $TMP/vm-$name-serial1.pipe"
    log_info_msg "Calvados console listening on $TMP/vm-$name-serial2.pipe"
    chmod +x "$TMP/vm-$name-real.exec"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name-real.exec") remain-on-exit on
    tmux_resize $name 80 24
}

start_cisco_nxos () {
    name=$NAME
    log_info_msg "Start Cisco Nexus 9000v $name"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,tftp=$TMP/metadata-$name,hostfwd=tcp:127.0.0.1:${ssh}-:22${hostfwd+,hostfwd=}${hostfwd}"
    netargs="$netargs -device e1000,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh cisco
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device e1000,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"

qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/cisco-nxos.img $TMP/cisco-$name.img
mkdir -p $TMP/metadata-$name
cat - cisco-common.conf cisco-$name.conf <<'END' 2>/dev/null > $TMP/metadata-$name/nxos_config.txt
hostname $name
interface mgmt0
 vrf member management
 ip address dhcp
 no shut
!
username cisco password 5 \$1\$JbjM\$0SIk5bmGRwYFTUjZAQeTb. role network-admin
username cisco sshkey $(cat $TMP/id_rsa.pub)
!
vrf context management
 ip route 0.0.0.0/0 mgmt0 10.0.2.2
!
END
genisoimage -iso-level 2 -l -V config-1 -relaxed-filenames -quiet -o $TMP/cisco-$name.iso $TMP/metadata-$name

exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-8G} \
     -cpu host \
     -smp ${CPU:-2} \
     -machine smm=off \
     -device virtio-rng \
     \
     -boot c \
     -bios /usr/share/qemu/OVMF.fd \
     -device ahci,id=ahci0,bus=pci.0 \
     -drive file=$TMP/cisco-$name.img,if=none,media=disk,id=boot \
     -device ide-hd,bus=ahci0.0,drive=boot,id=boot \
     -drive file=$TMP/cisco-$name.iso,if=ide,media=cdrom \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on          $TMP/vm-$name-console.pipe"
    log_info_msg "aux console listening on      $TMP/vm-$name-serial1.pipe"
    log_info_msg "Calvados console listening on $TMP/vm-$name-serial2.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
    tmux_resize $name 80 24
}

start_hp_vsr1000 () {
    name=$NAME
    log_info_msg "Start HP VSR1000 $name"
    netargs=""
    ssh=$(tcp_port)
    netargs="$netargs -netdev user,id=oob,hostfwd=tcp:127.0.0.1:${ssh}-:22,tftp=$TMP/tftp-$name,tftp-server-name=10.0.2.2,bootfile=device.cfg"
    netargs="$netargs -device virtio-net-pci,mac=$oobmac,netdev=oob"
    [ x$SWITCH_MON = x ] || netargs="$netargs -object filter-dump,id=f1,netdev=oob,file=$TMP/oob-$name.pcap"
    add_ssh_config $NAME $ssh hp
    count=0
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -netdev vde,sock=$TMP/switch-$net.sock,id=net${count}"
        netargs="$netargs -device e1000,mac=$mac,netdev=net${count}"
        count=$((count+1))
    done

    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
printf "\e]2;$name\a"

qemu-img create -q -f qcow2 -F qcow2 -b $PWD/../images/hp-vsr1000.img $TMP/hp-$name.img
mkdir -p $TMP/tftp-$name
cat - hp-common.conf hp-$name.conf <<END 2>/dev/null > $TMP/tftp-$name/device.cfg
sysname $name
#
ip vpn-instance MGMT
#
interface GigabitEthernet1/0
 ip binding vpn-instance MGMT
 ip address dhcp-alloc
 port link-mode route
#
user-interface aux 0
 authentication-mode none
 user-role network-admin
#
user-interface class vty
 authentication-mode scheme
 user-role network-operator
 protocol inbound ssh
 idle-timeout 4320
#
ssh server enable
scp server enable
netconf ssh server enable
#
local-user hp class manage
 password hash $h$6$dkd9frSpy+qcpgMj$iiCwWc2oAvm05vThYeywTmkjH0ZvrLonkpx+l0NlsEzycMKBGzE7X6PvWldWoBNA5Y3yDjMVetXrDwbhyIrHRQ==
 service-type ssh
 authorization-attribute user-role network-admin
 authorization-attribute user-role network-operator
#
ssh user hp service-type all authentication-type any assign publickey sshkey
#
public-key peer sshkey
 public-key-code begin
$(ssh-keygen -e -m PKCS8 -f $TMP/id_rsa.pub \
   | grep -v '^---' \
   | base64 -d \
   | od -t x1 -An -w32 | tr -d ' ' | tr 'a-f' 'A-F')
 public-key-code end
 peer-public-key end
#
END

exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(command -v qemu-system-x86_64) -- \
     -enable-kvm \
     -no-user-config -nodefaults \
     -display none \
     -m ${MEM:-1G} \
     -cpu host \
     -device virtio-rng \
     \
     -boot c \
     -drive file=$TMP/hp-$name.img,if=ide,media=disk \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server=on,wait=off \
     -mon chardev=con0,mode=readline \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux set-option -wt $(tmux new-window -Pdn $name "$TMP/vm-$name.exec") remain-on-exit on
    tmux_resize $name 80 24
}

########################################################################
# Services
#

template () {
    input="$1"
    output="$2"
    shift 2
    args="$(echo $@ | sed 's/ /,/g')"
    python3 - <<EOF > $output
import os
from jinja2 import Template, Environment, FileSystemLoader, StrictUndefined
from ansible.plugins.filter.core import regex_search, regex_replace
from ansible_collections.ansible.utils.plugins.filter.ipaddr import ipaddr
from ansible_collections.ansible.utils.plugins.filter.ipmath import ipmath
from yaml import safe_load

env = Environment(loader=FileSystemLoader("."),
                  trim_blocks=True,
                  lstrip_blocks=True,
                  keep_trailing_newline=True)
env.undefined = StrictUndefined
env.filters['regex_search'] = regex_search
env.filters['regex_replace'] = regex_replace
env.filters['ipaddr'] = ipaddr
env.filters['ipmath'] = ipmath
env.globals['yaml'] = lambda f: safe_load(open(f))

template = env.get_template("${input}")
print(template.render(uts=os.environ.get("uts"), ${args}))
EOF
    case $output in
        /*) ;;
        *)
            grep -Fqx /$output .gitignore 2>/dev/null || echo /$output >> .gitignore
            ;;
    esac
}

execute () {
    command="$1"
    shift
    if [ -n "$netns" ]; then
        ip netns exec $netns "$command" "$@"
    else
        "$command" "$@"
    fi
}

service () {
    kind=$1
    shift

    case $kind in
        nginx)
            log_begin_msg "Running nginx"
            mkdir /var/log/nginx
            mkdir -p /tmp/nginx/www
            echo $uts > /tmp/nginx/www/index.html
            for size in 10M 100M 1G 10G 100G; do
                dd if=/dev/zero of=/tmp/nginx/www/$size bs=1 count=1 seek=$size 2> /dev/null
            done
            execute nginx -c /mnt/common/nginx.conf
            log_ok_msg "nginx started"
            ;;
        bird)
            log_begin_msg "Running bird${netns+, netns=}$netns"
            [ -d /run/bird ] || mkdir -p /run/bird
            if [ -f /mnt/lab/bird.$uts.$netns.conf ]; then
                execute bird -s /var/run/bird.$netns.ctl -c /mnt/lab/bird.$uts.$netns.conf "$@"
            elif [ -f /mnt/lab/bird.$uts.conf ] && [ -z "$netns" ]; then
                execute bird -c /mnt/lab/bird.$uts.conf "$@"
            elif [ -f /mnt/lab/bird.conf ]; then
                execute bird -c /mnt/lab/bird.conf "$@"
            fi
            if [ -f /mnt/lab/bird6.$uts.$netns.conf ]; then
                execute bird6 -s /var/run/bird6.$netns.ctl -c /mnt/lab/bird6.$uts.$netns.conf "$@"
            elif [ -f /mnt/lab/bird6.$uts.conf ] && [ -z "$netns" ]; then
                execute bird6 -c /mnt/lab/bird6.$uts.conf "$@"
            elif [ -f /mnt/lab/bird6.conf ]; then
                execute bird6 -c /mnt/lab/bird6.conf "$@"
            fi
            if [ -f /mnt/lab/bird2.$uts.$netns.conf ]; then
                execute bird2 -s /var/run/bird.$netns.ctl -c /mnt/lab/bird2.$uts.$netns.conf "$@"
            elif [ -f /mnt/lab/bird2.$uts.conf ] && [ -z "$netns" ]; then
                execute bird2 -c /mnt/lab/bird2.$uts.conf "$@"
            elif [ -f /mnt/lab/bird2.conf ]; then
                execute bird2 -c /mnt/lab/bird2.conf "$@"
            fi
            log_ok_msg "bird started${netns+, netns=}$netns"
            ;;
        quagga|frr)
            log_begin_msg "Running $kind"
            rm /etc/gshadow /etc/shadow
            touch /etc/gshadow /etc/shadow
            for name in quagga frr; do
                addgroup --quiet --system ${name}vty
                addgroup --quiet --system ${name}
                adduser --quiet \
                    --system \
                    --ingroup $name \
                    --home /var/run/${name}/ \
                    --no-create-home \
                    ${name}
                mkdir -p /var/log/quagga /var/run/quagga
                mkdir -p /var/log/frr /var/run/frr
                setfacl -m u:${name}:rwx /var/log/quagga /var/run/quagga /var/log/frr /var/run/frr
            done
            services=$(ls /mnt/lab/$kind-*.conf 2> /dev/null \
                           | sed "s+/mnt/lab/$kind-\([^.-]*\).*+\1+" \
                           | sort -r | uniq)
            for svc in $services; do
                for p in "" /usr/lib/frr/ /usr/lib/quagga/ ""; do
                    ! command -v $p$svc > /dev/null || break
                done
                if [ -f /mnt/lab/$kind-$svc.$uts.conf ]; then
                    eval set -- \$${svc}_args
                    execute $p$svc -d -f /mnt/lab/$kind-$svc.$uts.conf -A 127.0.0.1 "$@"
                elif [ -f /mnt/lab/$kind-$svc.conf ]; then
                    eval set -- \$${svc}_args
                    execute $p$svc -d -f /mnt/lab/$kind-$svc.conf -A 127.0.0.1 "$@"
                fi
            done
            log_ok_msg "$kind started"
            ;;
        gobgp)
            log_begin_msg "Running gobgp"
            execute gobgpd -f /mnt/lab/gobgp.$uts.conf -t yaml -p -s unix --disable-stdlog &
            log_ok_msg "gobgp started"
            ;;
        radvd)
            cfg="${1:-radvd.$uts.conf}"
            log_begin_msg "Running radvd ($cfg)"
            execute radvd -l /var/log/radvd.log -u radvd -C /mnt/lab/"$cfg"
            log_ok_msg "radvd started ($cfg)"
            ;;
        unbound)
            cfg="${1:-unbound.$uts.conf}"
            log_begin_msg "Running unbound ($cfg)"
            execute unbound -c /mnt/lab/"$cfg"
            log_ok_msg "unbound started ($cfg)"
            ;;
        ndppd)
            cfg="${1:-ndppd.$uts.conf}"
            log_begin_msg "Running ndppd ($cfg)"
            execute ndppd -d -c /mnt/lab/"$cfg"
            log_ok_msg "ndppd started ($cfg)"
            ;;
        dnsmasq)
            log_begin_msg "Running dnsmasq"
            mkdir /var/run/dnsmasq
            execute dnsmasq \
                --conf-file=/dev/null \
                --no-hosts \
                --user=root \
                --dhcp-leasefile=/tmp/dnsmasq.leases \
                "$@"
            log_ok_msg "dnsmasq started"
            ;;
        *)
            log_begin_msg "Running $kind"
            execute "$kind" "$@"
            log_ok_msg "$kind started"
            ;;
    esac
}

onhost () {
    case $# in
        0)
            [ x"$STATE" != x"SETUP" ] || return 1
            ;;
        *)
            ! onhost || "$@"
            ;;
    esac
}

run () {
    [ x"$STATE" != x"SETUP" ] || return 0
    display_help
    exit 0
}

########################################################################
# FSM
#

export STATE=${STATE:-BEGIN}
case $$,$STATE in
    1,BEGIN)
        # In initrd
        log_info_msg "image started for $uts"
        hostname ${uts}
        export PATH=/usr/local/bin:/usr/bin:/bin:/sbin:/usr/local/sbin:/usr/sbin
        export HOME=/root

        [ ! -f /modules ] || {
            log_info_msg "Loading modules"
            . /modules
        }

        overlay=/
        [ ! -f /init ] || {
            overlay=/tmp/target/overlay
            log_begin_msg "Setup root file system"
            mount -n -t tmpfs tmpfs /tmp -o rw
            mkdir /tmp/target
            mkdir /tmp/target/ro
            mkdir /tmp/target/overlay
            mount -n -t 9p    rootshare /tmp/target/ro      -o trans=virtio,version=9p2000.u,msize=104857600,ro
            mkdir /tmp/target/rw
            mount -n -t tmpfs tmpfs     /tmp/target/rw      -o rw
            mkdir /tmp/target/rw/workdir
            mkdir /tmp/target/rw/upperdir
            mount -n -t aufs aufs /tmp/target/overlay \
                  -o noxino,noatime,dirs=/tmp/target/rw/upperdir:/tmp/target/ro=ro \
                  2> /dev/null || \
                mount -n -t overlayfs overlayfs /tmp/target/overlay \
                      -o lowerdir=/tmp/target/ro,upperdir=/tmp/target/rw/upperdir,noatime \
                      2> /dev/null || \
                mount -n -t overlay overlayfs /tmp/target/overlay \
                      -o lowerdir=/tmp/target/ro,upperdir=/tmp/target/rw/upperdir,workdir=/tmp/target/rw/workdir,noatime \
                      2> /dev/null ||
                log_error_msg "Unable to mount AUFS/overlayfs"
            mount -n -t proc  proc  /tmp/target/overlay/proc
            mount -n -t tmpfs tmpfs /tmp/target/overlay/mnt
            log_ok_msg "Root file system setup"
        }

        log_begin_msg "Clean /tmp and /run"
        mount -n -t sysfs sys $overlay/sys
        for fs in /run /var/run /var/tmp /var/log /tmp; do
            if [ -d $overlay$fs ] && [ ! -h $overlay$fs ]; then
                mount -t tmpfs tmpfs $overlay$fs -o rw,nosuid,nodev
            fi
        done
        log_ok_msg "/tmp, /run and others are clean"

        [ ! -f /init ] || {
            log_begin_msg "Mount /root"
            mount -t 9p homeshare /tmp/target/overlay/root -o trans=virtio,version=9p2000.L,msize=104857600,access=any,rw || \
                log_error_msg "Unable to mount /root"
            [ ! -d /tmp/target/overlay/root/.ssh ] || {
                mount -t tmpfs tmpfs /tmp/target/overlay/root/.ssh -o rw,nosuid,nodev
                chmod 0700 /tmp/target/overlay/root/.ssh
            }
            log_ok_msg "/root mounted"
            log_begin_msg "Mount /lib/modules"
            mount -t 9p moduleshare /tmp/target/overlay/lib/modules -o trans=virtio,version=9p2000.L,msize=104857600,access=0,ro || \
                log_error_msg "Unable to mount /lib/modules"
            log_ok_msg "/root and /lib/modules mounted"

            log_begin_msg "Mount /mnt/lab"
            mkdir /tmp/target/overlay/mnt/lab /tmp/target/overlay/mnt/common
            mount -t 9p labshare /tmp/target/overlay/mnt/lab -o trans=virtio,version=9p2000.L,msize=104857600,access=any,rw || \
                log_error_msg "Unable to mount /mnt/lab"
            mount -t 9p commonshare /tmp/target/overlay/mnt/common -o trans=virtio,version=9p2000.L,msize=104857600,access=any,ro || \
                log_error_msg "Unable to mount /mnt/common"
            log_ok_msg "/mnt/lab and /mnt/common mounted"

            log_begin_msg "Mount /tmp/lab"
            mkdir /tmp/target/overlay/tmp/lab
            mount -t 9p tmpshare /tmp/target/overlay/tmp/lab -o trans=virtio,version=9p2000.L,msize=104857600,access=any,rw || \
                log_error_msg "Unable to mount /tmp/lab"
            log_ok_msg "/tmp/lab mounted"

            # Also, debugfs and configfs if they are available.
            mount -n -t debugfs debugfs /tmp/target/overlay/sys/kernel/debug 2> /dev/null || true
            mount -n -t configfs configfs /tmp/target/overlay/sys/kernel/config 2> /dev/null || true

            log_info_msg "Change root"
            export STATE=CHROOTED
            exec chroot /tmp/target/overlay /mnt/lab/setup
        }
        export STATE=CHROOTED
        /mnt/lab/setup
        exit 1                  # unreachable
        ;;

    *,CHROOTED)
        log_begin_msg "Setting /etc/hosts"
        cat <<EOF > /tmp/hosts
127.0.0.1       localhost.localdomain localhost
127.0.1.1       ${uts}

::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts
EOF
        mount --bind /tmp/hosts /etc/hosts
        log_ok_msg "/etc/hosts configured"

        rm -f /etc/machine-id
        mount | grep -q '^devtmpfs' || {
            log_begin_msg "Starting udev"
            udev_log=err
            mount -n --make-private -o size=10M,mode=0755 -t devtmpfs devtmpfs /dev
            rm -f /etc/udev/rules.d/70-persistent-net.rules
            udevadm info --cleanup-db
            for udev in /lib/systemd/systemd-udevd /usr/lib/systemd/systemd-udevd $(command -v udevd 2> /dev/null); do
                [ ! -x $udev ] || break
            done
            $udev --daemon
            udevadm trigger --action=add
            udevadm settle
            mkdir /dev/shm && mount -n -t tmpfs tmpfs /dev/shm
            log_ok_msg "udev started"
        }

        for p in /dev/vd??*; do
            [ -f $p ] || continue
            mkdir /mnt/${p#/dev/}
            mount $p /mnt/${p#/dev/}
            for d in proc sys dev; do
                [ ! -d /mnt/${p#/dev/}/$d ] || mount --bind /$d /mnt/${p#/dev/}/$d
            done
        done

        [ ! -f /proc/sys/kernel/core_pattern ] || {
            ulimit -c unlimited
            sysctl -qw kernel.core_pattern=/tmp/core.%h.%e.%t.%p
            sysctl -qw fs.suid_dumpable=1
        }

        log_info_msg "Setup interfaces"
        modprobe dummy 2>/dev/null || true
        ip link add dummy0 type dummy 2> /dev/null || true
        sleep 0.5               # Some interfaces may take some time to appear
        i=0
        for intf in /sys/class/net/*; do
            intf=${intf##*/}
            ip a l dev $intf 2> /dev/null >/dev/null || continue
            ip link set up dev $intf || true
            # Instead of waiting for DAD to finish, just disable it
            sysctl -qw net/ipv6/conf/$intf/accept_dad=0
        done
        sysctl -qw net/ipv6/conf/default/accept_dad=0

        log_info_msg "Start syslog"
        cat <<EOF > /tmp/rsyslogd.conf
module(load="imuxsock")
*.*   -/var/log/syslog
EOF
        rsyslogd -f /tmp/rsyslogd.conf

        for intf in /sys/class/net/*; do
            case $(cat $intf/address) in
                $oobmac)
                    intf=${intf##*/}
                    log_info_msg "Setup OOB interface on $intf"
                    dhclient $intf
                    # Run sshd in a not very secure way
                    mkdir /dev/pts
                    mount -n -t devpts devpts /dev/pts
                    mkdir /var/run/sshd
                    $(command -v sshd) \
                        -f /dev/null \
                        -h /tmp/lab/id_rsa \
                        -o AuthorizedKeysFile=/tmp/lab/id_rsa.pub \
                        -o StrictModes=no \
                        -o PrintLastLog=no
                    break
                    ;;
            esac
        done


        unset SHLVL
        if [ -n "$NOGETTY" ]; then
            export STATE=SETUP
            . /mnt/lab/setup
            export STATE=SHELL
            exec /mnt/lab/setup
        else
            log_info_msg "Setup terminal"
            export STATE=GETTY
            exec setsid /sbin/agetty -L ttyS0 -a root -l /mnt/lab/setup -i 115200 $TERM
        fi
        ;;

    *,GETTY)
        log_begin_msg "Setup terminal size"
        previous=$(stty -g)
        stty raw -echo min 0 time 5
        printf '\0337\033[r\033[999;999H\033[6n\0338' > /dev/tty
        IFS='[;R' read -r _ rows cols _ < /dev/tty || true
        stty "$previous"
        stty cols "$cols" rows "$rows"
        log_ok_msg "Terminal size is $cols×$rows"

        log_begin_msg "Setup additional commands"
        mkdir /tmp/tools
        cat <<EOF > /tmp/tools/reboot
#!/bin/sh
echo b > /proc/sysrq-trigger
EOF
        cat <<EOF > /tmp/tools/halt
#!/bin/sh
echo b > /proc/sysrq-trigger
EOF
        chmod +x /tmp/tools/*
        log_ok_msg "System can be halted with halt or reboot"

        export PATH=/tmp/tools:/mnt/common/bin:$PATH
        export STATE=SETUP
        . /mnt/lab/setup
        touch /tmp/ready
        export STATE=SHELL
        exec /mnt/lab/setup
        ;;

    *,SHELL)
        while true; do
            log_info_msg "Spawning a shell"
            cd /mnt/lab
            export SSH_TTY=$(tty)
            if [ -f $HOME/.zshrc ]; then
                /bin/zsh -i
            else
                /bin/bash -i
            fi || sleep 1
        done
        ;;

    *,BEGIN)
        [ $(id -u) != 0 ] || {
            log_error_msg "You should not run this as root"
            exit 1
        }
        PROGNAME="$(readlink -f "$0")"
        PROGARGS="$@"
        ROOT="$(readlink -f "${ROOT:-/}")" # Root filesystem
        KERNEL="$(readlink -f "${1:-/boot/vmlinuz-$(uname -r)}")" # Kernel
        PATH="$PATH":/usr/local/sbin:/usr/sbin:/sbin
        LABNAME="${LABNAME:-${PROGNAME##*/lab-}}"
        LABNAME="${LABNAME%/*}"
        LABNAME="${LABNAME:-lab}"
        [ $# -lt 1 ] || shift
        check_dependencies
        setup_screen
        setup_tmp
        ;;
esac

# Local Variables:
# mode: sh
# indent-tabs-mode: nil
# sh-basic-offset: 4
# End:
